package local.redlan.glados;

import java.util.ArrayList;
import java.util.concurrent.BlockingQueue;

/**
 * InOrOutput_Watcher is used to poll specified InOrOutput object at a regular intervals.
 * if there is a change in the returend value a event is created and placed in the EventDispatchQueue
 * @author warpsr
 *
 */
public class InOrOutput_Watcher implements Runnable
{
   /**
    * an ArrayList<Watchable> with IO Objects that are to be polled at the interval
    */
   private ArrayList<Watchable> watchList = new ArrayList<>();
   /**
    * Boolean keepWatching "could" be set to false to stop the watcher thread
    */
   private Boolean keepWatching = true;
   /**
    * int interval this is the time in ms that it waits before polling again
    */
   private int interval = 1000;
   /**
    * the queue the events generated by the watcher are put into
    */
   private BlockingQueue<IO_Event> EventDispatchQueue;
   
   /**
    * InOrOutput_Watcher constructor
    * takes an EventDispatchQueue and interval as agruments to create an instance of the watcher
    * @param EventDispatchQueue BlockingQueue<IO_Event> the queue the events generated by the watcher are put into
    * @param interval int this is the time in ms that it waits before polling again
    */
   public InOrOutput_Watcher(BlockingQueue<IO_Event> EventDispatchQueue, int interval)
   {
      this.EventDispatchQueue = Glados.EventDispatchQueue;
      this.interval = interval;
   }
   
   /**
    * method called by the IO object in order to have itself added to the list of objects to poll
    * @param iOPut Watchable the object to be added to the watchList
    */
   public void watchThis(Watchable iOPut)
   {
      watchList.add(iOPut);
   }
   
   /**
    * method called by the IO object in order to have itself removed from the list of objects to poll
    * @param iOPut Watchable the object to be removed from the watchList
    */
   public void stopWatchingThis(Watchable iOPut)
   {
      watchList.remove(iOPut);
   }
   
   /**
    * the main loop of the InOrOutput_Watcher it polls all the IO Objects in the watchList then waits for the 
    * specified interval and polls them again.
    */
   @Override
   public void run()
   {
      while(keepWatching)
      {
         for(Watchable iOPut:watchList)
         {
            iOPut.watch();
            IO_Event temp = new IO_Event();
            temp.setEventSource(iOPut.getEventSource());
            temp.setIntvalue(Integer.parseInt(iOPut.getNewValue()));
            temp.setSubscribtion(iOPut.getIOPutIDNumber());
            EventDispatchQueue.add(temp);
         }
         try
         {
            Thread.sleep(interval);
         }
         catch (InterruptedException e)
         {
            // TODO Auto-generated catch block
            e.printStackTrace();
         }
      }
      
   }
   
}
